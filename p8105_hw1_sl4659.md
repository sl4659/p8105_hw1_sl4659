p8105\_hw1\_sl4659
================
Shenglin Liu
9/19/2019

## Problem 1

``` r
library(tidyverse)
```

    ## ── Attaching packages ───────────────────────────────────────── tidyverse 1.2.1 ──

    ## ✔ ggplot2 3.2.1     ✔ purrr   0.3.2
    ## ✔ tibble  2.1.3     ✔ dplyr   0.8.3
    ## ✔ tidyr   0.8.3     ✔ stringr 1.4.0
    ## ✔ readr   1.3.1     ✔ forcats 0.4.0

    ## ── Conflicts ──────────────────────────────────────────── tidyverse_conflicts() ──
    ## ✖ dplyr::filter() masks stats::filter()
    ## ✖ dplyr::lag()    masks stats::lag()

``` r
test_df = tibble(
  # a random sample of size 8 from a standard Normal distribution
  vec_nor = rnorm(8),
  # logical vector indicating whether elements of the sample are greater than 0
  vec_log = vec_nor > 0,
  # character vector of length 8
  vec_char = c("My","name","is","Shenglin","Liu","I","Love","R"),
  # factor vector of length 8, with 3 different levels
  vec_fac = factor(c("high","low","low","medium","high","medium","low","low"))
)
# take the mean of each variable
mean(pull(test_df, vec_nor))
```

    ## [1] -0.1274136

``` r
mean(pull(test_df, vec_log))
```

    ## [1] 0.625

``` r
mean(pull(test_df, vec_char))
```

    ## Warning in mean.default(pull(test_df, vec_char)): argument is not numeric
    ## or logical: returning NA

    ## [1] NA

``` r
mean(pull(test_df, vec_fac))
```

    ## Warning in mean.default(pull(test_df, vec_fac)): argument is not numeric or
    ## logical: returning NA

    ## [1] NA

It works for vec\_nor and vec\_log and doesn’t work for vec\_char and
vec\_fac.

``` r
# as.numeric function
as.numeric(pull(test_df, vec_nor))
as.numeric(pull(test_df, vec_log))
as.numeric(pull(test_df, vec_char))
as.numeric(pull(test_df, vec_fac))
```

All variables can be converted to numeric except for vec\_char. It helps
explaining why mean() doesn’t work for vec\_char. However, mean()
doesn’t work for vec\_fac even if it can be converted to
numeric.

``` r
# convert logical to numeric, and multiply the random sample by the result
as.numeric(pull(test_df, vec_log))*pull(test_df, vec_nor)
```

    ## [1] 0.00000000 1.02027998 0.70164299 2.19264159 0.00000000 0.00000000
    ## [7] 0.03237604 0.01889760

``` r
# convert logical to factor, and multiply the random sample by the result
as.factor(pull(test_df, vec_log))*pull(test_df, vec_nor)
```

    ## Warning in Ops.factor(as.factor(pull(test_df, vec_log)), pull(test_df,
    ## vec_nor)): '*' not meaningful for factors

    ## [1] NA NA NA NA NA NA NA NA

``` r
# convert logical to factor, and then convert the result to numeric, and multiply the random sample by the result
as.numeric(as.factor(pull(test_df, vec_log)))*pull(test_df, vec_nor)
```

    ## [1] -0.98358563  2.04055995  1.40328599  4.38528317 -1.56120162 -2.44035952
    ## [7]  0.06475208  0.03779519

## Problem 2

``` r
test2_df = tibble(
  x = rnorm(500),
  y = rnorm(500),
  vec_log2 = x+y > 1,
  vec_num2 = as.numeric(vec_log2),
  vec_fac2 = as.factor(vec_log2)
)
```

The size of the dataset is 2500. The mean of x is -0.0245436. The median
of x is -0.0028959. The standard deviation of x is 1.0282595. The
proportion of cases for x + y \>1 is 0.258.
